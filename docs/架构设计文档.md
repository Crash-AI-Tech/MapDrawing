# NiubiAgent 架构设计文档

> **版本**: v4.0 — Cloudflare 全家桶架构
> **日期**: 2026-02-07
> **核心目标**: 高性能地图绘画、10万用户/5万并发、全量历史保留、多笔刷支持、可迁移至 App
> **技术基座**: TypeScript + Next.js 15 (App Router) + MapLibre GL + **Cloudflare (D1 + R2 + DO + Pages)**

---

## 〇、为什么选择 Cloudflare 全家桶

### 原方案的痛点

| 痛点 | Supabase 原方案 | Cloudflare 全家桶方案 |
|------|----------------|---------------------|
| **本地调试** | 需要 Docker 启动完整 PG 实例，启动慢 | D1 本地 = SQLite 文件，秒启动 |
| **平台割裂** | Vercel + Supabase + Cloudflare Workers = 3 个控制台 | 全部在 Cloudflare Dashboard 统一管理 |
| **内网延迟** | Workers → Supabase 跨境延迟 ~100ms | Workers → D1/R2 内网访问 ~5ms |
| **免费额度** | Supabase 闲置项目会暂停 | D1/R2/DO 免费额度慷慨，不暂停 |
| **冷启动** | Supabase Edge Functions 冷启动慢 | Cloudflare Workers 0ms 冷启动 |
| **运维复杂度** | 三方平台账号管理、密钥同步 | 一套 `wrangler` CLI 全搞定 |

### Cloudflare 全家桶组件

| 组件 | 用途 | 免费额度 | 对标 |
|------|------|---------|------|
| **Cloudflare Pages** | 前端托管 (Next.js SSR/SSG) | 无限带宽，500 构建/月 | Vercel |
| **Cloudflare D1** | 关系型数据库 (SQLite) | 5GB 存储，5M 读/天 | Supabase PostgreSQL |
| **Cloudflare R2** | 对象存储 (S3 兼容) | 10GB 存储，1M 请求/月 | Supabase Storage |
| **Durable Objects** | 有状态实时同步 | 10万请求/天，13K GB-s/天 | Supabase Realtime |
| **Workers KV** | 全局边缘缓存 | 10万读/天 | Redis |
| **Cloudflare Queues** | 消息队列 (异步写入) | 1万操作/天 | SQS |

---

## 一、系统全局架构

```
┌───────────────────────────────────────────────────────────────────────┐
│                         用户设备 (Web / App)                          │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │              Next.js App on Cloudflare Pages                     │  │
│  │                                                                  │  │
│  │  ┌──────────────┐  ┌──────────────────────────────────────────┐ │  │
│  │  │ Server Layer  │  │            Client Layer                  │ │  │
│  │  │  (Edge Runtime)│  │                                          │ │  │
│  │  │               │  │  ┌────────────────────────────────────┐ │ │  │
│  │  │ • Pages SSR   │  │  │     Drawing Engine (Core)           │ │ │  │
│  │  │ • API Routes  │  │  │  ┌──────────┐ ┌────────────────┐   │ │ │  │
│  │  │ • Middleware   │  │  │  │ Brush    │ │ Render Pipeline│   │ │ │  │
│  │  │               │  │  │  │ Registry │ │ (3-Layer Canvas)│  │ │ │  │
│  │  │ ┌───────────┐ │  │  │  └──────────┘ └────────────────┘   │ │ │  │
│  │  │ │ Lucia     │ │  │  │  ┌──────────┐ ┌────────────────┐   │ │ │  │
│  │  │ │ Auth      │ │  │  │  │ Input    │ │ History Mgr    │   │ │ │  │
│  │  │ └───────────┘ │  │  │  │ Manager  │ │ (Undo/Redo)    │   │ │ │  │
│  │  └───────┬───────┘  │  │  └──────────┘ └────────────────┘   │ │ │  │
│  │          │          │  └──────────────┬─────────────────────┘ │ │  │
│  │          │          │                 │                        │ │  │
│  │          │          │  ┌──────────────┴──────────────────┐    │ │  │
│  │          │          │  │  React Hooks                     │    │ │  │
│  │          │          │  │  useEngine / useAuth / useSync   │    │ │  │
│  │          │          │  └──────────────┬──────────────────┘    │ │  │
│  │          │          │                 │                        │ │  │
│  │          │          │  ┌──────────────┴──────────────────┐    │ │  │
│  │          │          │  │  Zustand Stores                  │    │ │  │
│  │          │          │  │  auth / drawing / ui             │    │ │  │
│  │          │          │  └─────────────────────────────────┘    │ │  │
│  │          │          └──────────────────────────────────────────┘ │  │
│  └──────────┼──────────────────────────┬───────────────────────────┘  │
└─────────────┼──────────────────────────┼──────────────────────────────┘
              │                          │
   ╔══════════╧══════════════════════════╧════════════════════╗
   ║                 Cloudflare 全家桶                         ║
   ╠═══════════════════════════════╦══════════════════════════╣
   ║                               ║                          ║
   ║  ┌──────────────┐             ║  ┌──────────────┐        ║
   ║  │   D1         │             ║  │  Durable     │        ║
   ║  │  (SQLite)    │◀──────batch─║──│  Objects     │        ║
   ║  │  用户 + 笔画  │   write     ║  │  (实时同步)   │        ║
   ║  └──────────────┘             ║  └──────────────┘        ║
   ║                               ║                          ║
   ║  ┌──────────────┐             ║  ┌──────────────┐        ║
   ║  │   R2         │             ║  │  Queue       │        ║
   ║  │  (对象存储)   │             ║  │  (消息队列)   │        ║
   ║  │  快照 + 归档  │             ║  │  异步写入     │        ║
   ║  └──────────────┘             ║  └──────────────┘        ║
   ║                               ║                          ║
   ║  ┌──────────────┐             ║  ┌──────────────┐        ║
   ║  │   KV         │             ║  │  CDN         │        ║
   ║  │  (边缘缓存)   │             ║  │  (全球分发)   │        ║
   ║  └──────────────┘             ║  └──────────────┘        ║
   ╚═══════════════════════════════╩══════════════════════════╝
```

### 核心设计原则

1. **单一平台** — 数据库、存储、计算、CDN 全部在 Cloudflare，内网访问，零跨境延迟
2. **引擎与框架解耦** — Drawing Engine 为纯 TypeScript，零 React 依赖，通过 hooks 桥接
3. **边缘优先** — Next.js 运行于 Cloudflare Pages Edge Runtime，全球 300+ PoP 就近响应
4. **自建认证** — Lucia Auth + D1，完全掌控用户数据，无第三方依赖
5. **渲染管线分离** — MapLibre GL（地图）与自定义 Canvas overlay（绘画）完全独立
6. **不可变事件流** — 所有绘画操作序列化为事件，天然支持 Undo/Redo、协同、离线

---

## 二、技术栈选型

| 层级 | 技术选型 | 理由 |
|------|---------|------|
| **框架** | **Next.js 15 (App Router)** | SSR/SSG 混合渲染、Edge Runtime、部署到 Cloudflare Pages |
| **语言** | **TypeScript 5.x (Strict)** | 全栈类型安全、引擎级代码的基础 |
| **地图引擎** | **MapLibre GL JS** | WebGL 渲染、60fps、矢量瓦片、旋转/倾斜/3D |
| **绘画渲染** | **OffscreenCanvas + WebGL2 Overlay** | GPU 加速笔刷、粒子/混合模式、不阻塞主线程 |
| **笔刷引擎** | **自研 BrushEngine (TS)** | 可插拔架构、压力感应、纹理映射 |
| **状态管理** | **Zustand** | 轻量（~1KB）、原生 TS、无 Provider boilerplate |
| **UI 组件** | **shadcn/ui + Tailwind CSS 4** | 可定制、无运行时、Radix 无障碍基础 |
| **认证** | **Lucia Auth v3** | 自建认证，完全掌控，支持 D1 适配器 |
| **数据库** | **Cloudflare D1 (SQLite)** | 边缘 SQLite，5GB 免费，本地开发即文件 |
| **对象存储** | **Cloudflare R2** | S3 兼容，10GB 免费，无出口费用 |
| **实时同步** | **Cloudflare Durable Objects** | 边缘低延迟 (<50ms)、按房间隔离、WebSocket Hibernation |
| **消息队列** | **Cloudflare Queues** | 异步批量写入，削峰填谷 |
| **边缘缓存** | **Cloudflare Workers KV** | 全球边缘缓存，热点数据 |
| **离线支持** | **IndexedDB + Service Worker** | 断网续画、重连自动 flush |
| **部署** | **Cloudflare Pages + Workers** | 一套 CLI (`wrangler`)，一个控制台 |
| **开发体验** | **wrangler dev** | D1/R2/DO 本地模拟，无需云端资源 |
| **移动端** | **Capacitor（预留）** | Next.js 导出为 static → Capacitor 打包 |

### Supabase → Cloudflare 迁移对照

| 功能 | Supabase 方案 | Cloudflare 方案 | 迁移难度 |
|------|--------------|----------------|---------|
| 数据库 | PostgreSQL + PostGIS | D1 (SQLite) + R-tree (rbush) | ⭐⭐ |
| 认证 | Supabase Auth | Lucia Auth + D1 + Argon2 | ⭐⭐⭐ |
| Session | JWT Cookie | Lucia Session + Cookie | ⭐⭐ |
| 文件存储 | Supabase Storage | R2 + Presigned URLs | ⭐ |
| 实时同步 | Supabase Realtime | Durable Objects (已有) | ✅ 保留 |
| Edge Functions | Supabase Edge Functions | Cloudflare Workers | ⭐ |
| RLS | PostgreSQL RLS | D1 + 应用层权限检查 | ⭐⭐ |

---

## 三、项目目录结构

```
niubiagent/
├── next.config.ts                  # Next.js 配置 (@cloudflare/next-on-pages)
├── wrangler.toml                   # Cloudflare Workers/Pages 配置
├── tailwind.config.ts              # Tailwind CSS 配置
├── tsconfig.json
├── package.json
├── .env.local                      # 本地环境变量
├── .dev.vars                       # Wrangler 本地 secrets
│
├── public/                         # 静态资源
│   ├── favicon.ico
│   └── manifest.json               # PWA manifest
│
├── docs/
│   └── 架构设计文档.md
│
├── drizzle/                        # 数据库迁移 (Drizzle ORM)
│   ├── schema.ts                   # D1 表结构定义
│   └── migrations/                 # SQL 迁移文件
│
├── src/
│   │
│   ├── app/                        # ★ Next.js App Router
│   │   ├── layout.tsx              # Root Layout: <html>, Provider 注入
│   │   ├── page.tsx                # 首页: SSR 重定向到 canvas
│   │   ├── globals.css             # Tailwind @import + 全局样式
│   │   │
│   │   ├── (auth)/                 # 认证路由组
│   │   │   ├── login/page.tsx      # 登录页 (Lucia Auth)
│   │   │   ├── register/page.tsx   # 注册页
│   │   │   ├── logout/route.ts     # 登出 API
│   │   │   └── forgot-password/page.tsx
│   │   │
│   │   ├── canvas/                 # ★ 核心画布页
│   │   │   ├── layout.tsx          # Canvas Layout: 全屏、无滚动
│   │   │   └── page.tsx            # 画布入口: MapCanvas + Toolbar
│   │   │
│   │   └── api/                    # Route Handlers (Edge Runtime)
│   │       ├── drawings/
│   │       │   ├── route.ts        # GET 视口查询 / POST 批量写入
│   │       │   └── [id]/route.ts   # PATCH / DELETE 单条操作
│   │       ├── profile/
│   │       │   └── route.ts        # GET / PATCH 用户 Profile
│   │       ├── upload/
│   │       │   └── route.ts        # R2 图片上传 (presigned URL)
│   │       └── ws/
│   │           └── route.ts        # WebSocket 升级代理 (可选)
│   │
│   ├── core/                       # ★ 框架无关的核心引擎（纯 TS）
│   │   │
│   │   ├── engine/
│   │   │   ├── DrawingEngine.ts    # 引擎入口
│   │   │   ├── StrokeManager.ts    # 笔画数据管理 (R-tree)
│   │   │   ├── HistoryManager.ts   # Undo/Redo
│   │   │   └── ViewportManager.ts  # 视口状态
│   │   │
│   │   ├── brushes/                # 笔刷系统
│   │   │   ├── BrushRegistry.ts
│   │   │   ├── BaseBrush.ts
│   │   │   ├── PencilBrush.ts
│   │   │   ├── MarkerBrush.ts
│   │   │   ├── SprayBrush.ts
│   │   │   └── HighlighterBrush.ts
│   │   │
│   │   ├── renderer/               # 渲染管线
│   │   │   ├── RenderPipeline.ts
│   │   │   ├── StrokeRenderer.ts
│   │   │   ├── TileCache.ts
│   │   │   └── OverlayManager.ts
│   │   │
│   │   ├── input/                  # 输入抽象层
│   │   │   ├── InputManager.ts
│   │   │   ├── GestureRecognizer.ts
│   │   │   └── PressureAdapter.ts
│   │   │
│   │   ├── sync/                   # 同步层
│   │   │   ├── EventStream.ts
│   │   │   ├── SyncManager.ts
│   │   │   ├── OfflineQueue.ts
│   │   │   └── DurableObjectClient.ts
│   │   │
│   │   └── types/                  # 核心类型
│   │       ├── stroke.ts
│   │       ├── events.ts
│   │       └── viewport.ts
│   │
│   ├── platform/                   # 平台适配层
│   │   └── web/
│   │       ├── MapLibreAdapter.ts
│   │       ├── WebCanvasProvider.ts
│   │       └── WebInputAdapter.ts
│   │
│   ├── hooks/                      # React Hooks
│   │   ├── useDrawingEngine.ts
│   │   ├── useAuth.ts              # Lucia Auth 状态
│   │   ├── useSync.ts
│   │   ├── useToolbar.ts
│   │   └── useViewport.ts
│   │
│   ├── stores/                     # Zustand 状态管理
│   │   ├── authStore.ts
│   │   ├── drawingStore.ts
│   │   └── uiStore.ts
│   │
│   ├── components/                 # React 组件
│   │   ├── ui/                     # shadcn/ui 基础组件
│   │   ├── canvas/
│   │   │   └── MapCanvas.tsx
│   │   ├── toolbar/
│   │   │   ├── Toolbar.tsx
│   │   │   ├── BrushPanel.tsx
│   │   │   └── ColorPicker.tsx
│   │   ├── auth/
│   │   │   ├── LoginForm.tsx
│   │   │   ├── RegisterForm.tsx
│   │   │   └── UserMenu.tsx
│   │   └── shared/
│   │       ├── LoadingOverlay.tsx
│   │       └── ErrorBoundary.tsx
│   │
│   ├── lib/                        # 工具函数 & 服务封装
│   │   ├── auth/                   # ★ Lucia Auth
│   │   │   ├── lucia.ts            # Lucia 实例 (D1 适配器)
│   │   │   ├── session.ts          # Session 管理
│   │   │   └── password.ts         # Argon2 哈希
│   │   │
│   │   ├── db/                     # ★ D1 数据库
│   │   │   ├── client.ts           # Drizzle ORM 客户端
│   │   │   ├── schema.ts           # 表结构定义
│   │   │   └── queries.ts          # 常用查询封装
│   │   │
│   │   ├── storage/                # ★ R2 存储
│   │   │   ├── r2.ts               # R2 操作封装
│   │   │   └── upload.ts           # 上传逻辑
│   │   │
│   │   ├── cloudflare/
│   │   │   ├── bindings.ts         # CF Bindings 类型定义
│   │   │   └── doClient.ts         # Durable Object 连接
│   │   │
│   │   └── utils/
│   │       ├── cn.ts
│   │       ├── uuid.ts
│   │       └── geo.ts
│   │
│   ├── workers/                    # Web Workers
│   │   ├── renderWorker.ts
│   │   └── syncWorker.ts
│   │
│   ├── middleware.ts               # ★ Next.js Edge Middleware (Auth 守卫)
│   │
│   └── env.d.ts                    # Cloudflare Bindings 类型声明
│
└── cf-workers/                     # ★ Cloudflare Workers 独立项目
    ├── wrangler.toml               # DO + Queue + Cron
    ├── package.json
    ├── tsconfig.json
    └── src/
        ├── index.ts                # Worker 入口
        ├── DrawingRoom.ts          # Durable Object: 实时房间
        ├── BatchWriter.ts          # Queue Consumer: 批量写入
        └── SnapshotWorker.ts       # Cron: 生成快照瓦片
```

---

## 四、Next.js + Cloudflare Pages 分层架构

### 4.1 Edge Runtime 与 Cloudflare Bindings

Next.js 在 Cloudflare Pages 上运行于 **Edge Runtime**，可直接访问 D1、R2、DO 等 Bindings：

```typescript
// src/env.d.ts — Cloudflare Bindings 类型声明
interface CloudflareEnv {
  // D1 数据库
  DB: D1Database;
  
  // R2 存储桶
  BUCKET: R2Bucket;
  
  // Durable Objects
  DRAWING_ROOM: DurableObjectNamespace;
  
  // KV 缓存
  CACHE: KVNamespace;
  
  // Queues
  STROKE_QUEUE: Queue<StrokeEvent>;
  
  // 环境变量
  AUTH_SECRET: string;
}

// 在 Route Handler 中访问
export const runtime = 'edge';

export async function GET(request: Request) {
  const env = (process.env as unknown as { env: CloudflareEnv }).env;
  // 或使用 getRequestContext() from @cloudflare/next-on-pages
  const { env } = getRequestContext();
  
  const result = await env.DB.prepare('SELECT * FROM drawings').all();
  return Response.json(result);
}
```

### 4.2 Server vs Client 边界

```
                        Edge Runtime (Cloudflare)        Client (Browser)
                        ┌──────────────────────┐    ┌───────────────────────┐
Layout / Page (RSC)     │  ✓ layout.tsx         │    │                       │
                        │  ✓ page.tsx (SSR)     │    │                       │
                        │  ✓ D1 直接读取         │    │                       │
                        │  ✓ 首屏 HTML 直出      │    │                       │
                        ├──────────────────────┤    │                       │
Route Handlers          │  ✓ api/drawings       │    │                       │
                        │  ✓ D1/R2/Queue 访问   │    │                       │
                        │  ✓ 批量写入 / 删除     │    │                       │
                        ├──────────────────────┤    │                       │
Middleware (Edge)       │  ✓ Lucia Session 验证 │    │                       │
                        │  ✓ 未登录重定向        │    │                       │
                        ├──────────────────────┤    ├───────────────────────┤
                        │                      │    │  ✓ MapCanvas.tsx      │
                        │                      │    │    'use client'       │
                        │                      │    │  ✓ Drawing Engine     │
                        │                      │    │  ✓ Toolbar / Panels   │
                        │                      │    │  ✓ Zustand stores     │
                        │                      │    │  ✓ DO WebSocket       │
                        └──────────────────────┘    └───────────────────────┘
```

### 4.3 Route Handler 示例 (D1)

```typescript
// src/app/api/drawings/route.ts
import { getRequestContext } from '@cloudflare/next-on-pages';
import { validateSession } from '@/lib/auth/session';

export const runtime = 'edge';

// GET /api/drawings?minLat=...&maxLat=...&minLng=...&maxLng=...
export async function GET(request: Request) {
  const { env } = getRequestContext();
  const url = new URL(request.url);

  const minLat = parseFloat(url.searchParams.get('minLat')!);
  const maxLat = parseFloat(url.searchParams.get('maxLat')!);
  const minLng = parseFloat(url.searchParams.get('minLng')!);
  const maxLng = parseFloat(url.searchParams.get('maxLng')!);

  // D1 查询（使用边界框过滤）
  const { results } = await env.DB.prepare(`
    SELECT * FROM drawings 
    WHERE min_lng <= ? AND max_lng >= ? 
      AND min_lat <= ? AND max_lat >= ?
    ORDER BY created_at DESC
    LIMIT 5000
  `).bind(maxLng, minLng, maxLat, minLat).all();

  return Response.json(results);
}

// POST /api/drawings (批量写入)
export async function POST(request: Request) {
  const { env } = getRequestContext();
  
  // 验证 Session
  const session = await validateSession(request, env);
  if (!session) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const strokes: StrokeData[] = await request.json();
  
  // 批量插入
  const stmt = env.DB.prepare(`
    INSERT INTO drawings (id, user_id, user_name, brush_id, color, opacity, size, 
                          points, min_lat, max_lat, min_lng, max_lng, created_zoom)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);

  const batch = strokes.map(s => stmt.bind(
    s.id, session.userId, session.userName, s.brushId, s.color, s.opacity, s.size,
    JSON.stringify(s.points), s.bounds.minLat, s.bounds.maxLat, 
    s.bounds.minLng, s.bounds.maxLng, s.createdZoom
  ));

  await env.DB.batch(batch);
  return Response.json({ ok: true, count: strokes.length });
}
```

### 4.4 Middleware 认证守卫 (Lucia Auth)

```typescript
// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { validateSessionToken } from './lib/auth/session';

const protectedRoutes = ['/canvas'];

export async function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  
  // 检查是否需要认证
  if (!protectedRoutes.some(r => pathname.startsWith(r))) {
    return NextResponse.next();
  }

  // 从 Cookie 读取 Session Token
  const sessionToken = request.cookies.get('session')?.value;
  
  if (!sessionToken) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // 验证 Session（在 Edge Runtime 中直接访问 D1）
  const session = await validateSessionToken(sessionToken);
  
  if (!session) {
    const response = NextResponse.redirect(new URL('/login', request.url));
    response.cookies.delete('session');
    return response;
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/canvas/:path*'],
};
```

---

## 五、Drawing Engine 核心设计

### 5.1 笔画数据模型

```typescript
/** 单个采样点 */
interface StrokePoint {
  x: number;           // 经度
  y: number;           // 纬度
  pressure: number;    // [0, 1]，无压力感应默认 0.5
  tiltX?: number;
  tiltY?: number;
  timestamp: number;   // ms，用于速度计算
}

/** 笔画数据 */
interface StrokeData {
  id: string;                // UUID v7（有序可排序）
  userId: string;
  userName: string;
  brushId: string;           // 笔刷类型标识
  color: string;             // 十六进制颜色
  opacity: number;           // [0, 1]
  size: number;              // 基准尺寸 px@zoom18
  points: StrokePoint[];
  bounds: GeoBounds;         // 包围盒（空间索引用）
  createdZoom: number;
  createdAt: number;         // Unix ms
  meta?: Record<string, unknown>;
}

/** 地理包围盒 */
interface GeoBounds {
  minLng: number; maxLng: number;
  minLat: number; maxLat: number;
}
```

### 5.2 笔刷架构

```typescript
abstract class BaseBrush {
  abstract readonly id: string;
  abstract readonly name: string;
  abstract readonly icon: string;

  abstract onStrokeStart(ctx: CanvasRenderingContext2D, point: StrokePoint, config: BrushConfig): void;
  abstract onStrokeMove(ctx: CanvasRenderingContext2D, points: StrokePoint[], config: BrushConfig): void;
  abstract onStrokeEnd(ctx: CanvasRenderingContext2D, config: BrushConfig): void;
  abstract renderFullStroke(ctx: CanvasRenderingContext2D, stroke: StrokeData): void;
}

interface BrushConfig {
  color: string;
  opacity: number;
  size: number;       // 当前 zoom 下的像素尺寸
  baseSize: number;   // 基准 @zoom18
  pressure: number;
}

// 注册表
class BrushRegistry {
  private brushes = new Map<string, BaseBrush>();
  register(brush: BaseBrush): void { this.brushes.set(brush.id, brush); }
  get(id: string): BaseBrush | undefined { return this.brushes.get(id); }
  getAll(): BaseBrush[] { return [...this.brushes.values()]; }
}
```

**四种笔刷：**

| 笔刷 | 渲染方式 | 参数范围 | 特殊效果 |
|------|---------|---------|---------|
| **铅笔** PencilBrush | `quadraticCurveTo` + 压力变宽 | size 0.5-5px | 贝塞尔平滑 |
| **马克笔** MarkerBrush | `lineWidth*3` + `globalAlpha=0.3` | size 2-20px | 同笔画不叠色（双 pass） |
| **喷枪** SprayBrush | 半径内随机粒子散点 | radius 5-50px | 高斯衰减密度 |
| **荧光笔** HighlighterBrush | `globalCompositeOperation='multiply'` | size 3-15px | 固定 opacity=0.4 |

扩展新笔刷只需 `implements BaseBrush` + `registry.register()`。

### 5.3 渲染管线（三层 Canvas）

```
PointerEvent → InputManager → DrawingEngine → BrushRegistry.render()
                                    │
                  ┌─────────────────┤
                  ▼                 ▼
           activeCanvas        tileCanvasPool
           (当前笔画)           (历史笔画缓存瓦片)
                  │                 │
                  └────────┬────────┘
                           ▼
                    compositeCanvas
                    (合成 → 叠加到 MapLibre)
```

| 层 | 用途 | 刷新频率 |
|----|------|---------|
| `tileCanvas` | 已完成笔画缓存为 256/512px 瓦片位图 | 视口变化 / 新笔画完成 |
| `activeCanvas` | 当前正在绘制的笔画 | 每个 PointerMove (~60fps) |
| `compositeCanvas` | 合成两层 + 叠加到地图 | 每帧 rAF |

**关键优化：**

1. **脏区渲染** — 只重绘变化区域
2. **瓦片缓存** — 避免每帧重绘历史
3. **Web Worker** — `OffscreenCanvas` 在 Worker 线程重绘
4. **LOD** — 低 zoom 下 Douglas-Peucker 简化
5. **R-tree 裁剪** — 只渲染视口内笔画

### 5.4 MapLibre ↔ Canvas 视口同步

```typescript
class OverlayManager {
  private map: maplibregl.Map;
  private canvas: HTMLCanvasElement;

  /** 每帧调用：同步 MapLibre 变换矩阵到 overlay canvas */
  syncTransform(): void {
    const zoom = this.map.getZoom();
    const bearing = this.map.getBearing();
    const pitch = this.map.getPitch();
    // project/unproject 映射 + CSS matrix3d
    this.canvas.style.transform = this.buildTransformCSS(zoom, bearing, pitch);
  }
}
```

---

## 九、实时同步架构 (Durable Objects + Queues)

### 9.1 不可变事件流

```typescript
type DrawEvent =
  | { type: 'STROKE_ADD';    stroke: StrokeData }
  | { type: 'STROKE_DELETE'; strokeId: string; userId: string }
  | { type: 'STROKE_UPDATE'; strokeId: string; patches: Partial<StrokeData> }
  | { type: 'CURSOR_MOVE';   userId: string; position: [number, number] }
```

### 9.2 Cloudflare Durable Objects (SQLite 后端)

Durable Objects 现在支持 SQLite 存储后端，且有免费额度：

```toml
# cf-workers/wrangler.toml
name = "niubiagent-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[[durable_objects.bindings]]
name = "DRAWING_ROOM"
class_name = "DrawingRoom"

[[migrations]]
tag = "v1"
new_sqlite_classes = ["DrawingRoom"]  # 使用 SQLite 后端

# D1 绑定
[[d1_databases]]
binding = "DB"
database_name = "niubiagent-db"
database_id = "xxx"

# R2 绑定
[[r2_buckets]]
binding = "BUCKET"
bucket_name = "niubiagent-storage"

# Queue 绑定
[[queues.producers]]
queue = "stroke-queue"
binding = "STROKE_QUEUE"

[[queues.consumers]]
queue = "stroke-queue"
max_batch_size = 100
max_batch_timeout = 5
```

### 9.3 DrawingRoom Durable Object (使用 Hibernation API)

```typescript
// cf-workers/src/DrawingRoom.ts
import { DurableObject } from 'cloudflare:workers';

interface Env {
  DB: D1Database;
  BUCKET: R2Bucket;
  STROKE_QUEUE: Queue<StrokeEvent>;
}

export class DrawingRoom extends DurableObject<Env> {
  private sessions: Map<WebSocket, SessionMeta> = new Map();
  
  // 使用 Hibernation API — 空闲时不计费
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    
    if (request.headers.get('Upgrade') === 'websocket') {
      const pair = new WebSocketPair();
      const [client, server] = Object.values(pair);
      
      // 验证 Token
      const token = url.searchParams.get('token');
      const user = await this.validateToken(token);
      if (!user) {
        return new Response('Unauthorized', { status: 401 });
      }
      
      // Hibernation API: 接受 WebSocket
      this.ctx.acceptWebSocket(server, [user.id]);
      
      this.sessions.set(server, {
        userId: user.id,
        userName: user.userName,
      });

      return new Response(null, { status: 101, webSocket: client });
    }

    return new Response('Expected WebSocket', { status: 400 });
  }

  // Hibernation API: WebSocket 消息处理
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): Promise<void> {
    if (typeof message !== 'string') return;
    
    const event: DrawEvent = JSON.parse(message);
    const session = this.sessions.get(ws);
    if (!session) return;

    // 添加序列号和时间戳
    const sequenced = {
      ...event,
      seq: Date.now(),
      userId: session.userId,
    };

    // 广播给其他客户端
    for (const [socket, meta] of this.sessions) {
      if (socket !== ws && socket.readyState === WebSocket.READY_STATE_OPEN) {
        socket.send(JSON.stringify(sequenced));
      }
    }

    // 笔画事件推入队列（异步持久化）
    if (event.type === 'STROKE_ADD') {
      await this.env.STROKE_QUEUE.send(event.stroke);
    }
  }

  // Hibernation API: WebSocket 关闭
  async webSocketClose(ws: WebSocket, code: number, reason: string): Promise<void> {
    this.sessions.delete(ws);
    
    // 通知其他用户
    const userId = ws.deserializeAttachment();
    this.broadcast({ type: 'USER_LEFT', userId });
  }

  // Hibernation API: WebSocket 错误
  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {
    this.sessions.delete(ws);
  }

  private broadcast(message: unknown): void {
    const data = JSON.stringify(message);
    for (const [socket] of this.sessions) {
      if (socket.readyState === WebSocket.READY_STATE_OPEN) {
        socket.send(data);
      }
    }
  }

  private async validateToken(token: string | null): Promise<UserInfo | null> {
    if (!token) return null;
    
    // 从 D1 验证 Session
    const result = await this.env.DB.prepare(`
      SELECT u.id, u.user_name FROM sessions s
      JOIN users u ON s.user_id = u.id
      WHERE s.id = ? AND s.expires_at > unixepoch()
    `).bind(token).first<{ id: string; user_name: string }>();
    
    if (!result) return null;
    return { id: result.id, userName: result.user_name };
  }
}
```

### 9.4 Queue Consumer (批量写入 D1)

```typescript
// cf-workers/src/BatchWriter.ts
interface Env {
  DB: D1Database;
}

export default {
  async queue(batch: MessageBatch<StrokeData>, env: Env): Promise<void> {
    if (batch.messages.length === 0) return;

    const strokes = batch.messages.map(m => m.body);
    
    // 批量插入
    const stmt = env.DB.prepare(`
      INSERT INTO drawings (id, user_id, user_name, brush_id, color, opacity, size, 
                            points, min_lat, max_lat, min_lng, max_lng, 
                            center_lat, center_lng, created_zoom)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    const batch = strokes.map(s => stmt.bind(
      s.id, s.userId, s.userName, s.brushId, s.color, s.opacity, s.size,
      JSON.stringify(s.points),
      s.bounds.minLat, s.bounds.maxLat, s.bounds.minLng, s.bounds.maxLng,
      (s.bounds.minLat + s.bounds.maxLat) / 2,
      (s.bounds.minLng + s.bounds.maxLng) / 2,
      s.createdZoom
    ));

    await env.DB.batch(batch);
    
    console.log(`Batch wrote ${strokes.length} strokes to D1`);
  },
};
```

### 9.5 离线支持

```
SyncManager
  ├── Online  → WebSocket → DO
  └── Offline → IndexedDB OfflineQueue
                    │
                    └── onReconnect: 按时间戳排序 → 批量发送 → 清空队列
```

### 9.6 数据流架构

```
        Client                    Cloudflare Edge                    D1
          │                            │                              │
          │── stroke event ───────────▶│                              │
          │                            │ Durable Object               │
          │                            │ 1. 广播给房间内其他客户端       │
          │◀── broadcast ──────────────│                              │
          │                            │ 2. 推入 Queue                 │
          │                            │──────────────▶│               │
          │                            │               │ Queue         │
          │                            │               │ (buffer 5s)   │
          │                            │               │──────────────▶│
          │                            │               │               │ D1
          │                            │               │               │ batch insert
          │                            │               │               │
```

---

## 十、R2 对象存储

### 10.1 用途

| 用途 | 说明 |
|------|------|
| **快照瓦片** | 预渲染的笔画位图 (PNG)，供观察者通道 |
| **用户头像** | 用户上传的头像图片 |
| **冷归档** | 6个月以上历史笔画的 Parquet 归档 |

### 10.2 上传 API (Presigned URL)

```typescript
// src/app/api/upload/route.ts
import { getRequestContext } from '@cloudflare/next-on-pages';
import { validateSession } from '@/lib/auth/session';

export const runtime = 'edge';

export async function POST(request: Request) {
  const { env } = getRequestContext();
  
  const session = await validateSession();
  if (!session) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { filename, contentType } = await request.json();
  const key = `avatars/${session.user.id}/${filename}`;

  // 直接上传到 R2
  const formData = await request.formData();
  const file = formData.get('file') as File;
  
  await env.BUCKET.put(key, file.stream(), {
    httpMetadata: { contentType },
  });

  const url = `https://r2.your-domain.com/${key}`;
  return Response.json({ url });
}
```

### 10.3 快照瓦片 Worker

```typescript
// cf-workers/src/SnapshotWorker.ts
interface Env {
  BUCKET: R2Bucket;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const [z, x, y] = parseTilePath(url.pathname); // /tiles/14/8192/5461.png

    // 从 R2 读取快照
    const obj = await env.BUCKET.get(`snapshots/${z}/${x}/${y}/latest.png`);
    
    if (obj) {
      return new Response(obj.body, {
        headers: {
          'Content-Type': 'image/png',
          'Cache-Control': 'public, max-age=1, stale-while-revalidate=5',
        },
      });
    }

    // 无笔画区域返回透明瓦片
    return new Response(TRANSPARENT_TILE, {
      headers: { 
        'Content-Type': 'image/png', 
        'Cache-Control': 'public, max-age=60' 
      },
    });
  },
};
```

---

## 七、数据库设计 (Cloudflare D1 / SQLite)

### 7.1 为什么选择 D1 而非 PostgreSQL

| 维度 | Supabase PostgreSQL | Cloudflare D1 |
|------|---------------------|---------------|
| **本地开发** | 需 Docker，启动慢 | 纯 SQLite 文件，秒启 |
| **空间索引** | PostGIS (GiST) 原生 | 无原生支持，用应用层 R-tree (rbush) |
| **访问延迟** | Workers → Supabase ~100ms | Workers → D1 ~5ms (内网) |
| **免费额度** | 500MB，闲置暂停 | 5GB，不暂停 |
| **迁移工具** | pg_dump | Drizzle ORM 迁移 |
| **适用场景** | 复杂查询、全文搜索 | 简单 CRUD、边缘读写 |

### 7.2 D1 表结构 (Drizzle ORM)

```typescript
// drizzle/schema.ts
import { sqliteTable, text, real, integer, blob } from 'drizzle-orm/sqlite-core';

// 用户表 (Lucia Auth)
export const users = sqliteTable('users', {
  id: text('id').primaryKey(),                    // Lucia 生成的 ID
  email: text('email').notNull().unique(),
  userName: text('user_name').notNull().unique(),
  passwordHash: text('password_hash').notNull(),   // Argon2 哈希
  avatarUrl: text('avatar_url'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
});

// Session 表 (Lucia Auth)
export const sessions = sqliteTable('sessions', {
  id: text('id').primaryKey(),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  expiresAt: integer('expires_at', { mode: 'timestamp' }).notNull(),
});

// 笔画数据表
export const drawings = sqliteTable('drawings', {
  id: text('id').primaryKey(),                    // UUID v7
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  userName: text('user_name').notNull(),
  brushId: text('brush_id').notNull().default('pencil'),
  color: text('color').notNull().default('#000000'),
  opacity: real('opacity').notNull().default(1.0),
  size: real('size').notNull().default(1.0),
  
  // 点数据 (JSON 数组)
  points: text('points', { mode: 'json' }).notNull().$type<StrokePoint[]>(),
  
  // 边界框 (用于空间查询)
  minLat: real('min_lat').notNull(),
  maxLat: real('max_lat').notNull(),
  minLng: real('min_lng').notNull(),
  maxLng: real('max_lng').notNull(),
  
  // 中心点 (用于聚类)
  centerLat: real('center_lat').notNull(),
  centerLng: real('center_lng').notNull(),
  
  createdZoom: integer('created_zoom').notNull().default(18),
  meta: text('meta', { mode: 'json' }).$type<Record<string, unknown>>(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
});

// 索引 (在 migrations 中创建)
```

### 7.3 D1 迁移文件

```sql
-- drizzle/migrations/0001_init.sql

-- 用户表
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  user_name TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  avatar_url TEXT,
  created_at INTEGER NOT NULL DEFAULT (unixepoch()),
  updated_at INTEGER NOT NULL DEFAULT (unixepoch())
);

-- Session 表
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  expires_at INTEGER NOT NULL
);

CREATE INDEX idx_sessions_user ON sessions(user_id);

-- 笔画表
CREATE TABLE drawings (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  user_name TEXT NOT NULL,
  brush_id TEXT NOT NULL DEFAULT 'pencil',
  color TEXT NOT NULL DEFAULT '#000000',
  opacity REAL NOT NULL DEFAULT 1.0,
  size REAL NOT NULL DEFAULT 1.0,
  points TEXT NOT NULL,  -- JSON 数组
  min_lat REAL NOT NULL,
  max_lat REAL NOT NULL,
  min_lng REAL NOT NULL,
  max_lng REAL NOT NULL,
  center_lat REAL NOT NULL,
  center_lng REAL NOT NULL,
  created_zoom INTEGER NOT NULL DEFAULT 18,
  meta TEXT,  -- JSON 对象
  created_at INTEGER NOT NULL DEFAULT (unixepoch()),
  updated_at INTEGER NOT NULL DEFAULT (unixepoch())
);

-- 空间查询索引 (边界框)
CREATE INDEX idx_drawings_bounds ON drawings(min_lng, max_lng, min_lat, max_lat);

-- 用户索引
CREATE INDEX idx_drawings_user ON drawings(user_id);

-- 时间索引
CREATE INDEX idx_drawings_created ON drawings(created_at DESC);
```

### 7.4 空间查询 (无 PostGIS)

D1 没有 PostGIS，但对于边界框查询，普通 SQLite 索引足够：

```typescript
// src/lib/db/queries.ts
import { getRequestContext } from '@cloudflare/next-on-pages';

export async function getDrawingsInViewport(
  minLat: number, maxLat: number,
  minLng: number, maxLng: number,
  limit = 5000
) {
  const { env } = getRequestContext();
  
  // 边界框过滤 (利用复合索引)
  const { results } = await env.DB.prepare(`
    SELECT * FROM drawings 
    WHERE min_lng <= ?1 AND max_lng >= ?2 
      AND min_lat <= ?3 AND max_lat >= ?4
    ORDER BY created_at DESC
    LIMIT ?5
  `).bind(maxLng, minLng, maxLat, minLat, limit).all();
  
  return results as DrawingRow[];
}
```

> **注意**: D1 适合边界框粗过滤。精确的空间索引（如 R-tree）在客户端使用 `rbush` 库完成。

### 7.5 与 Supabase PostgreSQL 对比

| 功能 | PostgreSQL 方案 | D1 方案 |
|------|---------------|---------|
| 空间索引 | `GiST (bounds)` | 边界框 + 应用层 R-tree |
| 全文搜索 | `tsvector` | 无原生支持 |
| RLS | 原生支持 | 应用层权限检查 |
| 事务 | 完整 ACID | 单语句事务 |
| 复杂查询 | CTE, Window Functions | 有限支持 |
| 批量写入 | `COPY` 命令 | `DB.batch()` |

---

## 八、认证系统 (Lucia Auth + D1)

### 8.1 为什么选择 Lucia Auth

| 维度 | Supabase Auth | Lucia Auth |
|------|--------------|------------|
| **控制权** | 托管服务，黑盒 | 完全自建，代码透明 |
| **存储** | Supabase PostgreSQL | 任意数据库 (D1 适配器) |
| **Session** | JWT + Cookie | 数据库 Session + Cookie |
| **OAuth** | 内置 | 需手动集成 |
| **迁移** | 受限于 Supabase | 随时切换数据库 |
| **依赖** | @supabase/auth | lucia (1个包) |

### 8.2 Lucia 实例配置

```typescript
// src/lib/auth/lucia.ts
import { Lucia } from 'lucia';
import { D1Adapter } from '@lucia-auth/adapter-sqlite';
import type { D1Database } from '@cloudflare/workers-types';

export function createLucia(db: D1Database) {
  const adapter = new D1Adapter(db, {
    user: 'users',
    session: 'sessions',
  });

  return new Lucia(adapter, {
    sessionCookie: {
      name: 'session',
      expires: false, // Session cookie
      attributes: {
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
      },
    },
    getUserAttributes: (attributes) => ({
      email: attributes.email,
      userName: attributes.user_name,
      avatarUrl: attributes.avatar_url,
    }),
  });
}

// 类型声明
declare module 'lucia' {
  interface Register {
    Lucia: ReturnType<typeof createLucia>;
    DatabaseUserAttributes: {
      email: string;
      user_name: string;
      avatar_url: string | null;
    };
  }
}
```

### 8.3 密码哈希 (Argon2)

```typescript
// src/lib/auth/password.ts
import { hash, verify } from '@node-rs/argon2';

// Argon2id 配置 (OWASP 推荐)
const ARGON2_OPTIONS = {
  memoryCost: 19456,  // 19 MB
  timeCost: 2,
  outputLen: 32,
  parallelism: 1,
};

export async function hashPassword(password: string): Promise<string> {
  return hash(password, ARGON2_OPTIONS);
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return verify(hash, password, ARGON2_OPTIONS);
}
```

### 8.4 注册流程

```typescript
// src/app/(auth)/register/actions.ts
'use server';

import { getRequestContext } from '@cloudflare/next-on-pages';
import { createLucia } from '@/lib/auth/lucia';
import { hashPassword } from '@/lib/auth/password';
import { generateId } from 'lucia';
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export async function register(formData: FormData) {
  const { env } = getRequestContext();
  const lucia = createLucia(env.DB);

  const email = formData.get('email') as string;
  const userName = formData.get('userName') as string;
  const password = formData.get('password') as string;

  // 验证输入...

  // 检查邮箱是否已存在
  const existing = await env.DB.prepare(
    'SELECT id FROM users WHERE email = ?'
  ).bind(email).first();
  
  if (existing) {
    return { error: '邮箱已被注册' };
  }

  // 创建用户
  const userId = generateId(15);
  const passwordHash = await hashPassword(password);

  await env.DB.prepare(`
    INSERT INTO users (id, email, user_name, password_hash)
    VALUES (?, ?, ?, ?)
  `).bind(userId, email, userName, passwordHash).run();

  // 创建 Session
  const session = await lucia.createSession(userId, {});
  const sessionCookie = lucia.createSessionCookie(session.id);

  (await cookies()).set(
    sessionCookie.name,
    sessionCookie.value,
    sessionCookie.attributes
  );

  redirect('/canvas');
}
```

### 8.5 登录流程

```typescript
// src/app/(auth)/login/actions.ts
'use server';

import { getRequestContext } from '@cloudflare/next-on-pages';
import { createLucia } from '@/lib/auth/lucia';
import { verifyPassword } from '@/lib/auth/password';
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export async function login(formData: FormData) {
  const { env } = getRequestContext();
  const lucia = createLucia(env.DB);

  const email = formData.get('email') as string;
  const password = formData.get('password') as string;

  // 查找用户
  const user = await env.DB.prepare(
    'SELECT id, password_hash FROM users WHERE email = ?'
  ).bind(email).first<{ id: string; password_hash: string }>();

  if (!user) {
    return { error: '邮箱或密码错误' };
  }

  // 验证密码
  const valid = await verifyPassword(password, user.password_hash);
  if (!valid) {
    return { error: '邮箱或密码错误' };
  }

  // 创建 Session
  const session = await lucia.createSession(user.id, {});
  const sessionCookie = lucia.createSessionCookie(session.id);

  (await cookies()).set(
    sessionCookie.name,
    sessionCookie.value,
    sessionCookie.attributes
  );

  redirect('/canvas');
}
```

### 8.6 Session 验证

```typescript
// src/lib/auth/session.ts
import { getRequestContext } from '@cloudflare/next-on-pages';
import { createLucia } from './lucia';
import { cookies } from 'next/headers';

export async function validateSession() {
  const { env } = getRequestContext();
  const lucia = createLucia(env.DB);
  
  const sessionId = (await cookies()).get(lucia.sessionCookieName)?.value;
  if (!sessionId) return null;

  const { session, user } = await lucia.validateSession(sessionId);
  
  // 刷新即将过期的 Session
  if (session?.fresh) {
    const sessionCookie = lucia.createSessionCookie(session.id);
    (await cookies()).set(
      sessionCookie.name,
      sessionCookie.value,
      sessionCookie.attributes
    );
  }

  if (!session) {
    const blankCookie = lucia.createBlankSessionCookie();
    (await cookies()).set(
      blankCookie.name,
      blankCookie.value,
      blankCookie.attributes
    );
    return null;
  }

  return { session, user };
}

// 用于 Route Handler 的版本
export async function validateSessionForRequest(request: Request, db: D1Database) {
  const lucia = createLucia(db);
  
  const cookieHeader = request.headers.get('Cookie');
  const sessionId = lucia.readSessionCookie(cookieHeader ?? '');
  if (!sessionId) return null;

  const { session, user } = await lucia.validateSession(sessionId);
  if (!session) return null;

  return { session, user };
}
```

### 8.7 登出

```typescript
// src/app/(auth)/logout/route.ts
import { getRequestContext } from '@cloudflare/next-on-pages';
import { createLucia } from '@/lib/auth/lucia';
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export const runtime = 'edge';

export async function POST() {
  const { env } = getRequestContext();
  const lucia = createLucia(env.DB);
  
  const sessionId = (await cookies()).get(lucia.sessionCookieName)?.value;
  
  if (sessionId) {
    await lucia.invalidateSession(sessionId);
  }

  const blankCookie = lucia.createBlankSessionCookie();
  (await cookies()).set(
    blankCookie.name,
    blankCookie.value,
    blankCookie.attributes
  );

  redirect('/login');
}
```

### 8.8 认证流程图

```
注册 → /register → Server Action → 
  1. 验证输入
  2. 检查邮箱唯一性 (D1)
  3. Argon2 哈希密码
  4. INSERT users (D1)
  5. lucia.createSession()
  6. Set Cookie → redirect /canvas

登录 → /login → Server Action →
  1. 查询用户 (D1)
  2. Argon2 验证密码
  3. lucia.createSession()
  4. Set Cookie → redirect /canvas

访问 /canvas → middleware.ts →
  1. 读取 session Cookie
  2. lucia.validateSession() (D1)
  3. 未登录? → redirect /login
  4. 已登录 → 继续

登出 → /logout → Route Handler →
  1. lucia.invalidateSession()
  2. 清除 Cookie → redirect /login
```

---

## 九、输入处理系统

### 9.1 统一输入管道

```typescript
class InputManager {
  // DOM PointerEvent → 引擎内部 InputEvent
  // - 合并 coalesced events
  // - 提取 pressure / tilt
  // - screen → geo 坐标转换
  // - 手势识别
  handlePointerDown(e: PointerEvent): void;
  handlePointerMove(e: PointerEvent): void;
  handlePointerUp(e: PointerEvent): void;
}
```

### 9.2 手势策略

| 手势 | 动作 |
|------|------|
| 单指 / 鼠标左键拖拽 | 绘画 |
| 双指捏合 | 缩放 |
| 双指平移 | 平移地图 |
| 鼠标中键拖拽 | 平移地图（绘画模式） |
| 三指轻触 (mobile) | 撤销 |
| Ctrl+Z / Cmd+Z | 撤销 |
| Ctrl+Shift+Z / Cmd+Shift+Z | 重做 |

### 9.3 防误触

- 多指时自动取消绘画
- 橡皮擦 tap-only (< 10px) 防误删
- 绘画模式禁用地图拖拽

---

## 十、Undo/Redo 系统

```typescript
type Command =
  | { type: 'ADD_STROKE';    stroke: StrokeData }
  | { type: 'DELETE_STROKE'; stroke: StrokeData }
  | { type: 'UPDATE_STROKE'; strokeId: string; before: Partial<StrokeData>; after: Partial<StrokeData> }

class HistoryManager {
  private undoStack: Command[] = [];
  private redoStack: Command[] = [];
  private readonly maxSize = 100;

  push(cmd: Command): void;
  undo(): Command | null;
  redo(): Command | null;
  canUndo(): boolean;
  canRedo(): boolean;
}
```

---

## 十一、性能指标

| 指标 | 目标 | 手段 |
|------|------|------|
| 绘画帧率 | >= 55 fps | OffscreenCanvas Worker + 脏区渲染 |
| 输入延迟 | < 16ms | getCoalescedEvents + 直接 Canvas |
| 同屏笔画 | 50,000+ | 瓦片缓存 + 视口裁剪 + LOD |
| 同步延迟 | < 100ms (画手) / < 2s (观察者) | DO 边缘广播 / CDN 快照 |
| 首屏 (3G) | < 1.5s | SSR 直出 + 代码分割 + 瓦片预加载 |
| LCP | < 1.2s | Server Component + Streaming |
| 离线恢复 | 0 丢失 | IndexedDB + 重连 flush |
| 内存 | < 200MB (10万笔画) | 瓦片缓存 + 视口外卸载 |
| 并发在线 | 50,000 | 角色分离 + 扇出树 + CDN 快照 |
| 数据库存储 | 1000万+ 笔画 | 空间+时间分区 + 冷存储 |

---

## 十一、规模化与高并发架构（10万用户 / 5万在线）

> **设计目标**：10 万注册用户，5 万同时在线，全部历史笔画永久保留。
> **核心约束**：当所有人聚焦在同一屏时，O(N²) 广播风暴是不可逾越的物理极限。
> 因此采用 **「角色分离 + 扇出树 + CDN 快照」** 三位一体方案。

### 11.1 瓶颈量化分析

| 指标 | 50K 同区域全绘画需求 | 单点架构极限 | 差距 | 结论 |
|------|---------------------|-------------|------|------|
| WS 连接 / 房间 | 50,000 | ~1,000 (单 DO) | 50x | 必须分片 |
| 消息广播 | 100K 事件/s × 50K = **50 亿次/s** | ~100 万次/s | 5000x | O(N²) 不可解 |
| 出站带宽 | ~2.5 TB/s | ~10 GB/s (CF 全球) | 250x | 物理不可能 |
| 数据库写入 | ~100K INSERT/s | ~5K/s (单 D1) | 20x | 需写缓冲 |

### 11.2 场景可行性矩阵

| 场景 | 可行性 | 方案 |
|------|--------|------|
| A. 10 万用户注册 + 全量历史保留 | ✅ | D1 + R2 冷存储 |
| B. 5 万在线分布在不同地图区域 | ✅ | 瓦片房间分片，每房间 < 200 人 |
| C. 5 万在线同区域，≤500 活跃画手 + 其余观察 | ✅ | 画手 WebSocket + 观察者 CDN 快照 |
| D. 热点区域瞬时爆发（如活动/比赛） | ✅ | 自动限流 + 排队入场 + 观察者降级 |
| E. 5 万在线同区域全部绘画 | ❌ | O(N²) 广播风暴，物理不可能 |

### 11.3 角色分离模型

```
所有连接用户被动态分为两种角色：

┌──────────────┐     实时 WebSocket (< 100ms)     ┌──────────────────┐
│  Active       │◀──────────────────────────────────│  Source DO        │
│  Drawer       │  双向：发送笔画 + 接收他人笔画     │  (瓦片房间)       │
│  (≤ 500/区域) │──────────────────────────────────▶│                   │
└──────────────┘                                   └────────┬──────────┘
                                                            │ 每 1~2s 生成
                                                            ▼
┌──────────────┐     HTTP 轮询 / SSE (1~2s 延迟)   ┌──────────────────┐
│  Observer     │◀──────────────────────────────────│  R2 快照瓦片      │
│  (无上限)     │  单向：只接收渲染后的位图           │  + CDN Cache      │
│              │                                    │                  │
└──────────────┘                                   └──────────────────┘
```

### 11.4 扇出树广播架构

```
                       ┌─────────────┐
                       │  Source DO   │  接收原始笔画事件
                       │  (1 per tile)│  验证 + 排序 + 分发
                       └──────┬──────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
        ┌──────────┐   ┌──────────┐   ┌──────────┐
        │ Relay DO │   │ Relay DO │   │ Relay DO │   每个最多 ~200 WS
        │  #1      │   │  #2      │   │  #3      │
        └────┬─────┘   └────┬─────┘   └────┬─────┘
             │              │              │
         ┌───┴───┐     ┌───┴───┐     ┌───┴───┐
         │clients│     │clients│     │clients│
         │1~200  │     │201~400│     │401~500│
         └───────┘     └───────┘     └───────┘
```

### 11.5 CDN 快照瓦片系统（观察者通道）

```
观察者浏览器                  Cloudflare CDN              R2 + DO
     │                            │                         │
     │── GET /tiles/{z}/{x}/{y} ──│                         │
     │                            │── Cache HIT? ───────────│
     │◀── 200 (cached bitmap) ────│   (1~2s TTL)           │
     │                            │                         │
     │   每 1~2s 重新请求          │── Cache MISS ──────────│
     │                            │◀── 从 R2 读取 ──────────│
     │◀── 200 (fresh bitmap) ─────│                         │
```

### 11.6 写入管线 (D1 + Queue)

```
画手客户端          Source DO              Queue           D1
    │                 │                    │                │
    │── stroke ──────▶│                    │                │
    │                 │── send to queue ──▶│                │
    │                 │                    │ batch 100条    │
    │                 │                    │ 或 5s 超时     │
    │                 │                    │──────────────▶ │
    │                 │                    │  DB.batch()    │
```

### 11.7 D1 存储策略

D1 单数据库限制 10GB，大规模场景需要分片或冷归档：

| 阶段 | 笔画数 | 存储 | 方案 |
|------|--------|------|------|
| 初期（3 月） | 10 万 | ~200 MB | 单 D1 足够 |
| 中期（1 年） | 500 万 | ~10 GB | 接近限制，需要冷归档 |
| 大规模（2+ 年） | 2000 万+ | ~40 GB | R2 冷归档 + 多 D1 分片 |

**冷归档策略**：

```typescript
// Cron Trigger: 每月归档 6 个月前的笔画
export default {
  async scheduled(event: ScheduledEvent, env: Env): Promise<void> {
    const sixMonthsAgo = Math.floor(Date.now() / 1000) - 180 * 24 * 60 * 60;
    
    // 1. 查询旧数据
    const { results } = await env.DB.prepare(`
      SELECT * FROM drawings WHERE created_at < ?
    `).bind(sixMonthsAgo).all();
    
    if (results.length === 0) return;
    
    // 2. 导出到 R2 (JSON 或 Parquet)
    const year = new Date().getFullYear();
    const month = new Date().getMonth();
    await env.BUCKET.put(
      `archive/${year}/${month}/drawings.json`,
      JSON.stringify(results),
      { httpMetadata: { contentType: 'application/json' } }
    );
    
    // 3. 删除 D1 中的旧数据
    await env.DB.prepare(`
      DELETE FROM drawings WHERE created_at < ?
    `).bind(sixMonthsAgo).run();
    
    console.log(`Archived ${results.length} drawings to R2`);
  },
};
```

### 11.8 LOD 多级加载

```
Zoom  0-8:   预渲染位图瓦片（R2 CDN，无矢量数据）
Zoom  9-13:  简化矢量（每笔画最多 20 个关键点）
Zoom 14-18:  完整矢量数据（按瓦片分片加载）
Zoom 19+:    超高清（原始精度）
```

### 11.9 规模化目标总结

| 维度 | 目标 | 技术手段 |
|------|------|---------|
| 注册用户 | 100,000 | Lucia Auth + D1 |
| 同时在线 | 50,000 | 角色分离：画手 WS + 观察者 CDN |
| 单区域活跃画手 | ≤500 | DO 扇出树 |
| 单区域观察者 | 无上限 | R2 快照 + CDN Cache |
| 实时延迟 (画手) | < 100ms | DO Hibernation API |
| 延迟 (观察者) | 1~2s | R2 + CDN |
| 历史笔画 | 2000 万+ | D1 热数据 + R2 冷归档 |
| 写入吞吐 | ~5K events/s | Queue + DB.batch() |

---

## 十三、部署架构 (全 Cloudflare)

```
                       用户请求
                          │
                          ▼
            ┌─────────────────────────────┐
            │    Cloudflare CDN           │
            │    (全球 300+ PoP)          │
            └─────────────┬───────────────┘
                          │
            ┌─────────────┴───────────────┐
            │                             │
            ▼                             ▼
   ┌─────────────────┐         ┌──────────────────┐
   │  Cloudflare      │         │  cf-workers/      │
   │  Pages           │         │  (独立 Worker)   │
   │                  │         │                   │
   │  Next.js 15      │         │  • Durable Objects│
   │  (Edge Runtime)  │         │    (DrawingRoom)  │
   │                  │         │                   │
   │  • SSR/SSG       │         │  • Queue Consumer │
   │  • Route Handlers│         │    (BatchWriter)  │
   │  • Middleware    │         │                   │
   │  • Static Assets │         │  • Cron Trigger   │
   │                  │         │    (Snapshot)     │
   └────────┬─────────┘         └─────────┬────────┘
            │                             │
            └──────────┬──────────────────┘
                       │
       ┌───────────────┼───────────────────┐
       │               │                   │
       ▼               ▼                   ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│     D1        │ │     R2        │ │     KV        │
│   (SQLite)    │ │  (对象存储)   │ │  (边缘缓存)   │
│               │ │               │ │               │
│  • users      │ │  • avatars/   │ │  • 热点数据   │
│  • sessions   │ │  • snapshots/ │ │  • 配置缓存   │
│  • drawings   │ │  • archive/   │ │               │
└──────────────┘ └──────────────┘ └──────────────┘
```

### 13.1 Wrangler 配置

```toml
# wrangler.toml (Next.js 项目根目录)
name = "niubiagent"
compatibility_date = "2024-01-01"
pages_build_output_dir = ".vercel/output/static"

# D1 绑定
[[d1_databases]]
binding = "DB"
database_name = "niubiagent-db"
database_id = "your-database-id"

# R2 绑定
[[r2_buckets]]
binding = "BUCKET"
bucket_name = "niubiagent-storage"

# KV 绑定
[[kv_namespaces]]
binding = "CACHE"
id = "your-kv-id"

# 环境变量
[vars]
AUTH_SECRET = "your-auth-secret"
```

```toml
# cf-workers/wrangler.toml (独立 Worker)
name = "niubiagent-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"

# Durable Objects
[[durable_objects.bindings]]
name = "DRAWING_ROOM"
class_name = "DrawingRoom"

[[migrations]]
tag = "v1"
new_sqlite_classes = ["DrawingRoom"]

# D1 绑定 (共享)
[[d1_databases]]
binding = "DB"
database_name = "niubiagent-db"
database_id = "your-database-id"

# R2 绑定 (共享)
[[r2_buckets]]
binding = "BUCKET"
bucket_name = "niubiagent-storage"

# Queue
[[queues.producers]]
queue = "stroke-queue"
binding = "STROKE_QUEUE"

[[queues.consumers]]
queue = "stroke-queue"
max_batch_size = 100
max_batch_timeout = 5

# Cron (快照生成)
[triggers]
crons = ["*/5 * * * *"]  # 每 5 分钟
```

### 13.2 环境变量

```bash
# .env.local (本地开发)
# D1/R2/DO 通过 wrangler dev 自动模拟，无需配置

# Auth
AUTH_SECRET="your-32-char-random-string"

# MapLibre (可选)
NEXT_PUBLIC_MAPLIBRE_STYLE_URL="https://tiles.example.com/style.json"

# DO WebSocket (生产环境)
NEXT_PUBLIC_DO_WEBSOCKET_URL="wss://niubiagent-worker.your-account.workers.dev"
```

```bash
# .dev.vars (Wrangler secrets，不提交到 Git)
AUTH_SECRET="your-32-char-random-string"
```

### 13.3 本地开发

```bash
# 1. 安装依赖
pnpm install

# 2. 创建本地 D1 数据库
pnpm wrangler d1 create niubiagent-db --local

# 3. 运行迁移
pnpm wrangler d1 execute niubiagent-db --local --file=drizzle/migrations/0001_init.sql

# 4. 启动 Next.js (Cloudflare Pages 模拟)
pnpm dev
# 或使用 wrangler pages dev
pnpm wrangler pages dev .vercel/output/static --d1=DB=niubiagent-db

# 5. 启动 cf-workers (独立终端)
cd cf-workers && pnpm wrangler dev
```

### 13.4 部署到生产

```bash
# 1. 创建 D1 数据库 (生产)
pnpm wrangler d1 create niubiagent-db

# 2. 创建 R2 存储桶
pnpm wrangler r2 bucket create niubiagent-storage

# 3. 运行迁移 (生产)
pnpm wrangler d1 execute niubiagent-db --file=drizzle/migrations/0001_init.sql

# 4. 设置 secrets
pnpm wrangler secret put AUTH_SECRET

# 5. 部署 Next.js 到 Pages
pnpm build
pnpm wrangler pages deploy .vercel/output/static

# 6. 部署 cf-workers
cd cf-workers && pnpm wrangler deploy
```

### 13.5 CI/CD (GitHub Actions)

```yaml
# .github/workflows/deploy.yml
name: Deploy to Cloudflare

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v2
        with:
          version: 9
          
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'
          
      - run: pnpm install
      
      - name: Build Next.js
        run: pnpm build
        
      - name: Deploy to Cloudflare Pages
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy .vercel/output/static --project-name=niubiagent

      - name: Deploy Workers
        working-directory: cf-workers
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: deploy
```

---

## 十四、迁移计划 (Supabase → Cloudflare 全家桶)

### 阶段一：基础设施迁移
- [ ] 创建 D1 数据库 + Drizzle ORM schema
- [ ] 创建 R2 存储桶
- [ ] 配置 wrangler.toml bindings
- [ ] 迁移现有数据 (如有)

### 阶段二：认证系统迁移
- [ ] 安装 Lucia Auth + @lucia-auth/adapter-sqlite
- [ ] 实现 users / sessions 表
- [ ] 实现注册/登录 Server Actions
- [ ] 实现 Middleware 认证守卫
- [ ] 迁移现有用户密码 (重新哈希)

### 阶段三：数据库层迁移
- [ ] 替换 Supabase client → D1 queries
- [ ] 更新 Route Handlers 使用 D1
- [ ] 更新 DO → D1 批量写入 (替换 Supabase REST)
- [ ] 测试空间查询性能

### 阶段四：存储迁移
- [ ] 实现 R2 上传 API
- [ ] 迁移头像存储
- [ ] 实现快照瓦片 Worker

### 阶段五：部署切换
- [ ] 配置 Cloudflare Pages 项目
- [ ] 设置 GitHub Actions CI/CD
- [ ] DNS 切换
- [ ] 删除 Supabase 项目

---

## 十五、Web → App 迁移计划

### 阶段一：核心引擎抽象（当前）
- `src/core/` 纯 TypeScript，零 React / Next.js 依赖
- 通过 `platform/` 适配层桥接
- 输入系统抽象为 `InputManager` 接口

### 阶段二：PWA
- `@ducanh2912/next-pwa` 集成 Service Worker
- IndexedDB 离线笔画
- `manifest.json` → 添加到主屏幕

### 阶段三：Capacitor 打包
- `next export` 生成纯静态文件
- `npx cap init` → iOS / Android 项目
- Capacitor 插件访问原生能力
- 替换 `WebInputAdapter` → `NativeInputAdapter`

### 阶段四：深度优化（按需）
- Drawing Engine → WASM 编译
- 渲染层 → Skia (CanvasKit) GPU 加速
- React Native 方案评估（如需原生渲染）

---

## 十六、执行路线图

### Phase 1：Cloudflare 基础设施 (Week 1)
- [ ] 安装依赖：`@cloudflare/next-on-pages`, `lucia`, `drizzle-orm`
- [ ] 配置 `wrangler.toml` (D1, R2, KV bindings)
- [ ] 创建 D1 数据库 + 运行迁移
- [ ] 实现 Lucia Auth (注册/登录/登出)
- [ ] 配置 Middleware 认证守卫

### Phase 2：地图 + 绘画引擎 (Week 2-3)
- [ ] MapLibre GL 集成（MapCanvas 组件）
- [ ] Canvas overlay 三层架构
- [ ] DrawingEngine + StrokeManager + ViewportManager
- [ ] BrushRegistry + 四种笔刷
- [ ] InputManager（Pointer Events 统一）
- [ ] HistoryManager (Undo/Redo)

### Phase 3：数据 + 同步 (Week 4-5)
- [ ] Route Handlers (D1 CRUD)
- [ ] Zustand stores (auth / drawing / ui)
- [ ] Cloudflare DO Worker (Hibernation API)
- [ ] Queue Consumer (批量写入 D1)
- [ ] SyncManager + OfflineQueue
- [ ] 视口数据加载策略

### Phase 4：UI + 优化 (Week 6-7)
- [ ] Toolbar / BrushPanel / ColorPicker 组件
- [ ] UserMenu / Profile 编辑
- [ ] R2 头像上传
- [ ] Web Worker 离屏渲染
- [ ] 瓦片缓存 + R-tree + LOD
- [ ] 性能调优

### Phase 5：规模化 (Week 8-9)
- [ ] 角色分离模型 (Active Drawer / Observer)
- [ ] DO 扇出树 (Source DO + Relay DO)
- [ ] R2 快照瓦片系统
- [ ] D1 冷归档 Cron
- [ ] 反压限流 + 自适应采样
- [ ] 负载测试 (k6 / Artillery)

### Phase 6：上线 (Week 10)
- [ ] PWA 配置
- [ ] Capacitor 验证打包
- [ ] E2E 测试 (Playwright)
- [ ] 部署到 Cloudflare Pages
- [ ] 监控告警 (Sentry)
- [ ] 正式上线

---

## 十七、成本估算 (Cloudflare 全家桶)

### 免费额度 vs 付费阈值

| 组件 | 免费额度 | 预估用量 (初期) | 是否超限 |
|------|---------|----------------|---------|
| **Pages** | 500 构建/月，无限带宽 | ~30 构建/月 | ✅ 免费 |
| **D1** | 5M 读/天，100K 写/天，5GB | ~100K 读/天，~10K 写/天，<1GB | ✅ 免费 |
| **R2** | 10GB，1M 请求/月 | ~1GB，~100K 请求/月 | ✅ 免费 |
| **DO** | 100K 请求/天，13K GB-s/天 | ~50K 请求/天 | ✅ 免费 |
| **KV** | 100K 读/天 | ~10K 读/天 | ✅ 免费 |
| **Queue** | 10K 操作/天 | ~5K 操作/天 | ✅ 免费 |

### 付费情况 (Workers Paid Plan: $5/月)

当用量超出免费额度时，需要升级到 Workers Paid Plan ($5/月 起)：

| 组件 | 付费后额度 | 超额费用 |
|------|-----------|---------|
| D1 | 25B 读/月，50M 写/月 | $0.001/M 读，$1/M 写 |
| R2 | 10GB | $0.015/GB/月 |
| DO | 1M 请求/月 | $0.15/M 请求 |
| Queue | 1M 操作/月 | $0.40/M 操作 |

**预估月成本**：
- 初期 (10K 用户)：**$0** (全免费)
- 中期 (50K 用户)：**$5** (付费计划基础费)
- 规模化 (100K 用户)：**$10-20** (根据实际用量)

### 对比 Supabase

| 维度 | Supabase Free | Supabase Pro | Cloudflare |
|------|--------------|--------------|------------|
| 月费 | $0 | $25 | $0-5 |
| 数据库 | 500MB | 8GB | 5GB (免费) |
| 存储 | 1GB | 100GB | 10GB (免费) |
| 边缘函数 | 50万/月 | 200万/月 | 无限 |
| 暂停风险 | 7天闲置暂停 | 无 | 无 |

**结论**：对于本项目，**Cloudflare 全家桶成本更低且无暂停风险**。
