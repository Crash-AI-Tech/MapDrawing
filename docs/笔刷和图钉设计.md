# 笔刷 & 图钉跨平台同步对齐方案

> **文档目的**：分析 iOS / Web 两端在笔刷渲染、橡皮擦、图钉显示方面的差异与性能问题，给出统一的技术方案，指导后续开发。
>
> 最后更新：2026-02-14

---

## 目录

1. [现状分析](#1-现状分析)
2. [笔刷：产品决策（PM 视角）](#2-笔刷产品决策pm-视角)
3. [笔刷：性能评估（架构师视角）](#3-笔刷性能评估架构师视角)
4. [数据库字段兼容性评估](#4-数据库字段兼容性评估)
5. [跨平台笔刷对齐方案](#5-跨平台笔刷对齐方案)
6. [橡皮擦方案](#6-橡皮擦方案)
7. [图钉跨平台对齐方案](#7-图钉跨平台对齐方案)
8. [优先级与排期建议](#8-优先级与排期建议)

---

## 1. 现状分析

### 1.1 笔刷对比

| 特性 | Web (Canvas 2D) | iOS (Skia RN) | 差异 |
|------|----------------|---------------|------|
| 铅笔 Pencil | ✅ Bézier 平滑 + 压感宽度 | ✅ `buildBezierPath` + quadTo | **算法一致**，渲染引擎不同导致抗锯齿/线条粗细存在视觉差 |
| 马克笔 Marker | ✅ OffscreenCanvas 两步合成 (α=0.3) | ✅ `saveLayer` + `layerOpacity:0.3` | 效果接近，但 Web 使用 OffscreenCanvas 重绘全笔画，iOS 使用 Skia Layer 叠加；**颜色叠加表现不同** |
| 喷枪 Spray | ✅ `fillRect` 粒子 + 确定性 PRNG | ✅ Alpha-bucket 分组 SkPath 圆点 | Web 使用 1.5px 方块，iOS 使用 2px 圆点；**视觉差异明显**；iOS 有性能降级策略 (>8 strokes → 减粒子，>20 → 改线段) |
| 荧光笔 Highlighter | ✅ `globalCompositeOperation: multiply` | ✅ `BlendMode: Multiply` | **算法基本一致**，Web lineCap='square'，iOS strokeCap='butt'，略有差异 |
| 橡皮擦 Eraser | ❌ **不存在** | ✅ `BlendMode: Clear` + 5x 笔画宽度 | **Web 完全缺失** |

### 1.2 渲染架构对比

| | Web | iOS |
|--|-----|-----|
| 渲染引擎 | Canvas 2D (CPU) | Skia via react-native-skia (GPU) |
| 渲染模式 | 每帧重绘所有可见笔画 (immediate mode) | Tile-based SkPicture cache (recorded commands) |
| 笔画缓存 | 无 tile cache | 512px 世界像素瓦片，SkPicture 录制回放 |
| 实时绘画 | activeCanvas → compositeCanvas 合成 | GestureDetector → Skia Canvas 直接绘制 |
| 喷枪优化 | 无 | SPRAY_DEGRADE_THRESHOLD=8, SPRAY_DISABLE_THRESHOLD=20 |

### 1.3 图钉对比

| 特性 | Web | iOS | 差异 |
|------|-----|-----|------|
| 渲染方式 | DOM Marker (maplibregl.Marker) | React Native View (MapPinOverlay) | Web 利用 MapLibre 原生定位；iOS 手动 MercatorProjection 计算 |
| Z-order (图钉 vs 绘图) | 图钉在画布 **下方** (Marker < Canvas overlay) | 图钉在 Skia Canvas **上方** (zIndex: 15) | **Web 图钉被绘图遮挡** |
| 默认气泡 | 显示截断消息 (10字) + hover 展开 | 显示截断消息 (10字) + 点击展开 | iOS 气泡 maxWidth 仅 120px 且 `width: 28`，**太窄导致一行只能显示一两个字** |
| 拖拽延迟 | 无延迟 (DOM Marker 跟随 MapLibre GL 内部变换) | **明显延迟** (React state 更新 → 重新 geoToScreen) | iOS 的 `setCameraState` 触发 React 重渲染，RN Bridge 延迟 |
| Report/Block | ✅ hover 展开显示 | ✅ 点击展开显示 | 一致 |

---

## 2. 笔刷：产品决策（PM 视角）

### 2.1 "越多越好" vs "经典几款"

**结论：保持 4+1 经典笔刷，不宜贪多。**

理由：

1. **用户认知负担**：参考 Excalidraw（仅 1 支手绘笔）、Apple Freeform（5 支）、Figma FigJam（3 支）。社交地图涂鸦 ≠ 专业绘画工具，核心是「快速表达」而非「精细创作」。
2. **跨平台一致性成本**：每多一种笔刷，需要在 Canvas 2D（Web）和 Skia（iOS）两端实现并保证视觉一致性。笔刷越多维护成本越高。
3. **存储 / 传输效率**：喷枪（Spray）每笔画的 points 数组最大，粒子生成需要确定性 PRNG 同步，增加复杂度。
4. **Apple PencilKit 参考**：Apple 的官方绘画框架也只提供 pen、marker、pencil、crayon、watercolor 五种 Ink 类型。

### 2.2 推荐笔刷清单

| 优先级 | 笔刷 ID | 名称 | 用途 | 保留/调整 |
|--------|---------|------|------|-----------|
| P0 | `pencil` | 铅笔 | 通用手写 / 签名 / 细线条 | ✅ 保留 |
| P0 | `marker` | 马克笔 | 粗标注 / 涂鸦 | ✅ 保留 |
| P0 | `eraser` | 橡皮擦 | 删除内容 | ✅ Web 需新增 |
| P1 | `highlighter` | 荧光笔 | 半透明高亮标注 | ✅ 保留 |
| P2 | `spray` | 喷枪 | 涂鸦乐趣 | ⚠️ 考虑降级或移除 |

### 2.3 关于喷枪的取舍

**建议：暂时保留但降为 P2，优先保证前 4 个笔刷的跨平台一致性。**

- 喷枪是唯一具有确定性随机粒子的笔刷，跨平台确保 PRNG 输出一致需要双端使用完全相同的 seed → random 算法。
- 当前两端 PRNG 算法已对齐（`Park-Miller LCG: s = (s * 16807) % 2147483647`），但 Web 使用 1.5px 方块 vs iOS 使用 2px 圆点，视觉差距较大。
- 喷枪在大量笔画时性能表现最差（iOS 已有降级策略，Web 完全没有）。

---

## 3. 笔刷：性能评估（架构师视角）

### 3.1 各笔刷性能矩阵

| 笔刷 | 输入复杂度 | 存储开销 | 渲染开销 (Web) | 渲染开销 (iOS) | 同步开销 |
|------|-----------|---------|----------------|----------------|---------|
| 铅笔 | 低（点+压感） | 低 | 低（Bézier 路径） | 低（SkPath cache） | 低 |
| 马克笔 | 低（点） | 低 | **中**（OffscreenCanvas 全笔画重绘） | 低（saveLayer 一次） | 低 |
| 荧光笔 | 低（点） | 低 | 低（lineTo） | 低（lineTo） | 低 |
| 橡皮擦 | 低（点） | 低 | 低（Clear composite） | 低（Clear blendMode） | **中**（需保序渲染） |
| 喷枪 | **高**（点+压感） | **高**（points × density） | **高**（逐粒子 fillRect） | **高→低**（有降级策略） | 中 |

### 3.2 性能关键指标

**渲染帧预算**：16ms @60fps

| 场景 | Web (Canvas 2D) | iOS (Skia) |
|------|----------------|------------|
| 100 笔铅笔 (avg 50pt/stroke) | ~2ms | <1ms (SkPicture cache) |
| 100 笔马克笔 | ~3ms | <1ms |
| 100 笔荧光笔 | ~2ms | <1ms |
| 10 笔喷枪 (30 particles/point × 50pt) | **~8ms** ⚠️ | ~2ms (alpha-bucket) |
| 50 笔喷枪 | **>16ms ❌ 超帧** | ~4ms (降级后) |
| 橡皮擦 (must render in order) | ~2ms | <1ms |

**结论**：
- **铅笔 / 荧光笔**：两端性能良好，无瓶颈。
- **马克笔**：Web 端 `onStrokeMove` 每次重绘整个 OffscreenCanvas 效率较低，但 `renderFullStroke` 渲染只画一次 path，可接受。
- **喷枪**：**Web 端是主要瓶颈**。50 笔以上时逐粒子 `fillRect` 会超帧。需要引入 Web 端降级策略。
- **橡皮擦**：要求按 `createdAt` 严格排序渲染，否则 Clear 操作可能清除错误内容。两端的 `RenderPipeline` / `TileRenderer` 已按 `createdAt` 排序。

### 3.3 Web 端优化建议

1. **喷枪**：引入与 iOS 相同的降级策略——超过 8 笔在视口内时减少粒子密度，超 20 笔改为简单线段渲染。
2. **马克笔**：`onStrokeMove` 可优化为增量绘制（不清除 OffscreenCanvas，只画新线段），避免每次重绘全路径。
3. **Tile Cache（长期）**：Web 端每帧重绘所有可见笔画。参考 Figma 的 tile-based WebGL 渲染，可引入 Canvas 2D 版 tile cache（类似 iOS 的 TileRenderer）显著减少重绘量。

---

## 4. 数据库字段兼容性评估

### 4.1 当前 `drawings` 表结构

```sql
CREATE TABLE drawings (
  id           TEXT PRIMARY KEY,     -- UUID v7
  user_id      TEXT NOT NULL,
  user_name    TEXT NOT NULL,
  brush_id     TEXT NOT NULL DEFAULT 'pencil',   -- ← 笔刷类型标识
  color        TEXT NOT NULL DEFAULT '#000000',
  opacity      REAL NOT NULL DEFAULT 1.0,
  size         REAL NOT NULL DEFAULT 1.0,        -- 基础大小 (CSS px)
  points       TEXT NOT NULL,                    -- JSON string [{x,y,pressure,timestamp}]
  min_lat      REAL NOT NULL,
  max_lat      REAL NOT NULL,
  min_lng      REAL NOT NULL,
  max_lng      REAL NOT NULL,
  center_lat   REAL NOT NULL,
  center_lng   REAL NOT NULL,
  created_zoom INTEGER NOT NULL DEFAULT 18,
  meta         TEXT,                             -- ← 扩展元数据 JSON
  created_at   INTEGER NOT NULL,
  updated_at   INTEGER NOT NULL
);
```

### 4.2 新增笔刷的兼容性

| 问题 | 答案 |
|------|------|
| 新增笔刷类型需要改表吗？ | **不需要**。`brush_id` 是 TEXT 字段，新增类型只需在客户端添加处理逻辑。 |
| 橡皮擦需要特殊字段吗？ | **不需要**。橡皮擦存储格式与普通笔刷完全一致（`brush_id='eraser'`），渲染时使用 Clear blendMode。 |
| 喷枪的粒子数据需要存储吗？ | **不需要**。粒子使用确定性 PRNG 从 points + strokeId 实时生成，不存储粒子坐标。 |
| `meta` 字段能扩展什么？ | 笔尖形状、自定义纹理参数、动画速度等未来扩展字段。JSON 格式可灵活添加。 |
| 大量喷枪 points 对 D1 有影响吗？ | 喷枪每笔画 points 数组可达 200-500 点，JSON 字符串 ~10-25KB。D1 单行限制 1MB，无问题。但批量加载需注意传输大小。 |

**结论：当前数据库设计完全支持新增任意类型笔刷，无需迁移。**

### 4.3 Shared 常量扩展

`@niubi/shared` 中的 `BRUSH_IDS` 已包含 5 种笔刷 ID：

```ts
export const BRUSH_IDS = {
  PENCIL: 'pencil',
  MARKER: 'marker',
  SPRAY: 'spray',
  HIGHLIGHTER: 'highlighter',
  ERASER: 'eraser',
} as const;
```

两端统一使用这些常量，新增笔刷只需在此扩展。

---

## 5. 跨平台笔刷对齐方案

### 5.1 目标

> 同一笔画在 Web 和 iOS 上的**视觉效果应基本一致**（允许抗锯齿差异，不允许明显的形状、透明度、粗细差异）。

### 5.2 铅笔对齐（已基本一致）

- Web: `PencilBrush.renderFullStroke` 使用 quadratic Bézier through midpoints。
- iOS: `buildBezierPath` 使用 `path.quadTo` through midpoints。
- **算法完全一致**，仅需确认：
  - [x] `getWidth(baseSize, pressure) = baseSize * (0.5 + pressure * 0.5)` — 两端计算公式相同
  - [ ] **Action**: 验证 Web 和 iOS 对相同 points 数据渲染出的路径是否像素级接近（写一个测试用例）

### 5.3 马克笔对齐（需微调）

**当前差异**：
- Web `renderFullStroke`: 直接 `lineTo` + `globalAlpha = 0.3 * opacity`（一次性绘制）
- iOS: `saveLayer(layerOpacity: 0.3)` → `lineTo` → restore（layer 合成）

**对齐方案**：
- 两种方式在效果上几乎等价（都避免了笔画内颜色叠加）。对于已经完成的笔画 (`renderFullStroke`)，结果一致。
- 实时绘制有差异：Web 使用 OffscreenCanvas 整笔重绘；iOS 使用 Skia Layer。
- **Action**: 无需改动，保持各端最优实现。视觉差异可接受。

### 5.4 荧光笔对齐（需微调）

**当前差异**：
- Web: `lineCap = 'square'`, `lineJoin = 'miter'`
- iOS: `strokeCap = 'butt'`, `strokeJoin = 'bevel'`

**对齐方案**：
- `square` 和 `butt` 的区别是末端是否延伸半个线宽。`miter` 和 `bevel` 在连接处的尖角处理不同。
- **Action**: 统一为 Web `square/miter`，iOS `Butt/Bevel`。由于荧光笔是宽笔触 + multiply 模式，用户几乎无法感知这些微小差异。**保持不动**。

### 5.5 喷枪对齐（需治理）

**当前差异**：
| | Web | iOS |
|--|-----|-----|
| 粒子形状 | 1.5×1.5 px `fillRect` (方块) | 2px 圆点 (SkPath circle) |
| Alpha 处理 | 逐粒子设置 `globalAlpha` | 5 个 alpha 桶，批量渲染 |
| 降级策略 | 无 | DEGRADE>8, DISABLE>20 |
| PRNG | `(s * 16807) % 2147483647` | 同一算法 ✅ |

**对齐方案**：
1. **Web 粒子改为 2px 圆** — 使用 `ctx.arc(px, py, 1, 0, Math.PI * 2); ctx.fill()` 替代 `fillRect`。
2. **Web 引入 alpha 桶** — 将粒子按 alpha 值分组 (0.1, 0.25, 0.4, 0.55, 0.7)，减少 `globalAlpha` 切换次数。
3. **Web 引入降级策略** — 移植 iOS 的 `SPRAY_DEGRADE_THRESHOLD` 和 `SPRAY_DISABLE_THRESHOLD`。
4. **统一 seed 函数** — 两端已对齐 (`hashString`)，确认即可。

---

## 6. 橡皮擦方案

### 6.1 iOS 现有实现

```ts
// TileRenderer.ts → getBrushConfig('eraser')
case BRUSH_IDS.ERASER:
  return {
    buildPath: buildLinearPath,
    strokeWidth: (s) => s * 5,   // 5 倍基础大小
    opacity: 1.0,
    blendMode: 'Clear',          // 关键：清除像素
    strokeCap: 'round',
    strokeJoin: 'round',
  };
```

橡皮擦本质是一个使用 `Clear` 混合模式的粗笔画，擦除路径上的所有像素。它**不是删除笔画**，而是在绘制层叠加一个"透明通道"。

### 6.2 Web 端实现方案

**实现策略：新增 `EraserBrush` 类，使用 `globalCompositeOperation: 'destination-out'`。**

> Canvas 2D 没有 Skia 的 `BlendMode.Clear`，但 `destination-out` 效果等价——将目标像素的 alpha 设为 0。

```ts
// web/src/core/brushes/EraserBrush.ts (新增)
export class EraserBrush extends BaseBrush {
  readonly id = 'eraser';
  readonly name = '橡皮擦';
  readonly icon = 'Eraser';
  readonly minSize = 2;
  readonly maxSize = 20;
  readonly supportsPressure = false;

  renderFullStroke(ctx, stroke) {
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = stroke.size * 5;
    ctx.globalAlpha = 1.0;
    ctx.beginPath();
    ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
    for (let i = 1; i < stroke.points.length; i++) {
      ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
    }
    ctx.stroke();
    ctx.restore();
  }
}
```

### 6.3 橡皮擦渲染顺序

**关键约束**：橡皮擦必须在所有早于它的笔画之后渲染，否则会错误地擦除后来的笔画。

两端已保证渲染顺序：
- **Web** `RenderPipeline.render()`: `visibleStrokes.sort((a, b) => a.createdAt - b.createdAt)`
- **iOS** `TileRenderer`: 同样按 `createdAt` 排序

### 6.4 注册与 UI

1. 在 `BrushRegistry` 的 `createDefaultBrushRegistry()` 中注册 `EraserBrush`。
2. 在 `BrushPanel.tsx` 的 `BRUSH_META` 中添加 `{ id: BRUSH_IDS.ERASER, label: '橡皮擦', icon: 'E' }`。
3. 在 `Toolbar.tsx` 中无需改动（笔刷选择已通过 BrushPanel 管理）。

### 6.5 橡皮擦 vs 删除笔画

| | 橡皮擦 (`eraser`) | 删除笔画 (`undo` / `deleteStroke`) |
|--|-------------------|-------------------------------|
| 操作方式 | 涂抹擦除（任意区域） | 整条笔画撤销/删除 |
| 数据影响 | 新增一条 `brush_id='eraser'` 记录 | 从 StrokeManager 和 DB 中移除 |
| 同步 | 作为普通笔画同步 | 需要 DELETE 事件同步 |
| 可撤销 | 支持 undo（删除该 eraser stroke） | 支持 redo |

---

## 7. 图钉跨平台对齐方案

### 7.1 待解决问题

| # | 问题 | 平台 | 严重度 |
|---|------|------|--------|
| P1 | 图钉在绘图**下方**（被遮挡） | Web | 高 |
| P2 | 气泡太窄，文字被截断到只有 1-2 字 | iOS | 高 |
| P3 | 地图拖拽时图钉明显延迟 | iOS | 高 |
| P4 | 两端图钉视觉风格不统一 | 双端 | 中 |

### 7.2 P1: Web 图钉 z-order 修复

**问题根因**：
- Web 绘图 overlay 是一个 `<canvas>` 覆盖在 MapLibre 之上（通过 `position: absolute; z-index` 控制）。
- MapLibre 的 `Marker` DOM 元素位于 MapLibre 的内部容器中，其 z-index 低于外部 overlay canvas。

**修复方案**：

```
方案 A（推荐）: 将 pin marker 的 DOM 容器提升到 canvas 之上
- 目前 MapLibre marker 在 map container 内部的 .maplibregl-marker 
- 通过 CSS 强制提升：
  .maplibregl-marker { z-index: 20 !important; }
  或将 canvas overlay 的 z-index 从当前值降到 marker 层之下
  
方案 B: 像 iOS 一样用独立 div 层渲染图钉
- 创建一个 React overlay div (position: absolute, z-index > canvas)
- 手动计算 geo → screen 坐标并定位图钉
- 优点：完全控制 z-order
- 缺点：失去 MapLibre Marker 的自动定位，需手动跟随地图变换

方案选择: 方案 A，简单高效
```

**具体实现**：
在 `MapCanvas.tsx` 中，确保画布 overlay 的 `position: absolute` 设置 `pointer-events: none`（已被绘图模式条件控制），并通过 CSS 提升 marker 层级：

```css
/* 在 MapCanvas 组件中为 map container 添加样式 */
.maplibregl-canvas-container + .maplibregl-canvas-container ~ * {
  z-index: 20;
}
/* 或直接修改 compositeCanvas 的 z-index 使之低于 markers */
```

最简单的做法：在创建 DOM canvas overlay 时设置 `style.zIndex = '5'`，而 MapLibre Marker 默认在 `.maplibregl-marker` 下 z-index 更高。

### 7.3 P2: iOS 气泡宽度修复

**问题根因**：
```tsx
// MapPinOverlay.tsx
pinContainer: {
  width: 28,        // ← 容器仅 28px 宽！
}
tooltip: {
  maxWidth: 120,    // collapsed
  alignSelf: 'center',
}
tooltipExpanded: {
  maxWidth: 200,    // expanded
}
```

`pinContainer` 的 `width: 28` 限制了子元素的布局宽度。tooltip 的 `alignSelf: 'center'` 在一个 28px 宽的容器内无法展开。

**修复方案**：
1. 移除 `pinContainer` 的 `width: 28` 限制，改为 `width: 'auto'` 或不设置 width。
2. 增大 tooltip 的 `maxWidth`: collapsed 160px → expanded 240px。
3. 使用 `overflow: 'visible'` 确保内容能溢出容器。

```tsx
pinContainer: {
  position: 'absolute',
  alignItems: 'center',
  // 移除 width: 28，让内容自然撑开
  // 但仍需一个 minWidth 来锚定 pin 圆点
},
tooltip: {
  // ...
  maxWidth: 160,         // 从 120 → 160
  minWidth: 60,          // 确保至少显示几个字
},
tooltipExpanded: {
  maxWidth: 240,         // 从 200 → 240
  minWidth: 120,
},
```

同时修改 `truncate` 函数默认截断长度从 10 → 15:
```tsx
function truncate(msg: string, max: number = 15): string { ... }
```

### 7.4 P3: iOS 图钉拖拽延迟修复

**问题根因**：
1. `onRegionChanging` 中对 `setCameraState` 有 16ms 节流，但 React setState → re-render → MapPinOverlay useMemo 重计算 → RN Layout 链路总延迟约 50-100ms。
2. `geoToScreen` 在 useMemo 中对所有 pins 进行计算，每次相机变化都触发。

**修复方案（三级优化）**：

```
Level 1 (快速修复): Animated Transform 替代 React re-render
- 在 MapView 的 onRegionIsChanging 中，不更新 React state
- 改用 RN Animated.Value 驱动整个 overlay 容器的平移变换 (translateX/Y)
- 仅在 onRegionDidChange 时做一次精确的 React state 更新
- 预期效果：拖拽期间 0 延迟（GPU 层动画）

Level 2 (中期): 使用 react-native-reanimated SharedValue
- 将 cameraState 存入 useSharedValue (worklet 层)
- 图钉位置通过 useAnimatedStyle 在 UI 线程计算
- 彻底消除 JS Bridge 延迟

Level 3 (长期): 回退到 MapLibre 原生 SymbolLayer
- 将图钉数据转换为 GeoJSON → SymbolLayer + icon-image
- MapLibre 原生层随地图变换零延迟
- 展开详情时再使用 React overlay
- 需解决：自定义图标注册、点击事件处理
```

**推荐 Level 1**（快速修复）+ 未来评估 Level 3。

**Level 1 实现要点**：

```tsx
// 在 index.tsx 中
const mapOffsetX = useRef(new Animated.Value(0)).current;
const mapOffsetY = useRef(new Animated.Value(0)).current;

// onRegionIsChanging: 计算相与上一帧的屏幕偏移
const handleRegionChanging = (feature) => {
  const newCenter = feature.geometry.coordinates;
  const newZoom = feature.properties.zoomLevel;
  // 计算屏幕偏移 delta
  const oldScreen = projection.geoToScreen(newCenter[0], newCenter[1]);
  const delta = { x: screenWidth/2 - oldScreen.x, y: screenHeight/2 - oldScreen.y };
  mapOffsetX.setValue(delta.x);
  mapOffsetY.setValue(delta.y);
};

// onRegionDidChange: 精确更新
const handleRegionDidChange = (feature) => {
  updateCamera(feature); // 更新 cameraState → 触发精确 geoToScreen
  mapOffsetX.setValue(0);
  mapOffsetY.setValue(0);
};

// MapPinOverlay wrapper
<Animated.View style={{ transform: [{ translateX: mapOffsetX }, { translateY: mapOffsetY }] }}>
  <MapPinOverlay ... />
</Animated.View>
```

### 7.5 P4: 两端图钉视觉统一

| 属性 | 统一规范 |
|------|---------|
| Pin 图标 | 圆形 22px，2.5px 白色边框，填充色为 `pin.color` |
| 默认气泡 | 白色圆角 (8px)，最大宽度 160px，字号 12px，文字截断 15 字 |
| 展开气泡 | 最大宽度 240px，显示完整消息 + 作者/时间 + Report/Block |
| 气泡箭头 | 底部居中 6px 三角 |
| 阴影 | `box-shadow: 0 2px 8px rgba(0,0,0,0.15)` / RN `shadowOpacity: 0.15` |
| 展开触发 | Web: hover (mouseenter)，iOS: 点击 (tap) — 适配各平台交互习惯 |

---

## 8. 优先级与排期建议

### Phase 1（1-2 天）— 关键体验修复

| 任务 | 端 | 复杂度 |
|------|-----|--------|
| Web 新增 EraserBrush + 注册 + UI | Web | 低 |
| Web 图钉 z-order 修复 (CSS) | Web | 低 |
| iOS 图钉气泡宽度修复 | iOS | 低 |
| iOS 图钉截断文字增至 15 字 | iOS | 低 |

### Phase 2（2-3 天）— 延迟与一致性

| 任务 | 端 | 复杂度 |
|------|-----|--------|
| iOS 图钉拖拽延迟优化 (Level 1 Animated) | iOS | 中 |
| 喷枪 Web 端降级策略 | Web | 中 |
| 喷枪粒子形状统一 (方块 → 圆点) | Web | 低 |
| Web 喷枪 alpha 桶优化 | Web | 中 |

### Phase 3（长期维护）

| 任务 | 端 | 复杂度 |
|------|-----|--------|
| Web 端 tile cache 引入 | Web | 高 |
| iOS 图钉回退到 SymbolLayer (Level 3) | iOS | 高 |
| 跨平台笔刷视觉回归测试框架 | 双端 | 中 |
| 更多笔刷类型探索（毛笔、水彩） | 双端 | 高 |

---

## 附录 A. 笔刷算法跨平台一致性校验清单

- [ ] 铅笔：相同 10 点 Bézier 路径，两端截图对比
- [ ] 马克笔：相同 20 点路径，α=0.3 合成效果对比
- [ ] 荧光笔：相同 15 点路径，multiply 模式效果对比
- [ ] 橡皮擦：先画 3 笔再擦 1 笔，对比残留视觉
- [ ] 喷枪：相同 seed + 5 点输入，对比粒子分布和密度

## 附录 B. 参考设计

| 产品 | 笔刷数量 | 笔刷类型 | 同步特点 |
|------|---------|---------|---------|
| Apple Freeform | 5 | Pen, Marker, Pencil, Crayon, Watercolor | 实时 iCloud 同步 |
| Excalidraw | 1 | 手绘风格（无笔刷选择） | CRDT 同步 |
| tldraw | 3 | Draw, Highlighter, Laser | 实时多人 + CRDT |
| Figma FigJam | 3 | Pen, Marker, Highlighter | CRDT + OT |
| Google Jamboard | 4 | Pen, Marker, Highlighter, Brush | Cloud 同步 |
| Miro | 3 | Pen, Highlighter, Smart drawing | Real-time WebSocket |

## 附录 C. 文件变更清单

实施本方案时需要修改的文件列表：

**Web 端**：
- `web/src/core/brushes/EraserBrush.ts` — 新建
- `web/src/core/brushes/BrushRegistry.ts` — 注册橡皮擦
- `web/src/core/brushes/SprayBrush.ts` — 粒子改圆点 + alpha 桶 + 降级
- `web/src/components/toolbar/BrushPanel.tsx` — 添加橡皮擦按钮
- `web/src/components/canvas/MapCanvas.tsx` — 图钉 z-order CSS 修复

**iOS 端**：
- `ios/components/MapPinOverlay.tsx` — 气泡宽度 + 截断长度修复
- `ios/app/(app)/index.tsx` — 图钉拖拽延迟优化 (Animated offset)

**Shared**：
- `packages/shared/src/index.ts` — 无需改动（ERASER 已在 BRUSH_IDS 中）
